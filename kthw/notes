

To do:
-----
* Worker nodes
* Consider creating a systemd library with common functions like install, uninstall,
    status, etc. for easier management
* Logging library
* Consider a copying engine - you write a file that describes what to copy where,
    and the engine makes sure to perform it - instead of writing it in the 'distribute' function
* Consider ansible?
* etcd: test that systemd service is running
* control-plane: add test


Bugs:
-----
* when running clean_nodes in control-plane, it deletes
kubectl in all the controller machines, but we need it 
to generate the kubeconfigs


Deployment process:
--------
When we come to deploy on the nodes, we basically do the following steps:
- install prerequisites (check if fulfilled, if not install)
- scp files (service files, certificates, kubeconfigs, setup script, etc.)
- copy files to correct location (setup script?)
- install systemd service
- run systemd service

We want to allow the user at any moment:
- stop the services
- uninstall the services
- prune (delete everything we've copied)
- check status




Planning of deployment process
=============================

(talking here about etcd, but relevant for control plane and kubelet)

etcd_agent.sh
-----------
commands:
	- install_binaries:
		purpose: install etcd software and necessary prerequisites
		condition: not binaries installed
		runs:
		- install_binaries
		side effects: etcd is installed on the machine (state 3)
		
	- uninstall_binaries:
		purpose: remove etcd software
		condition: not loaded
		depends: stop
		runs:
		- uninstall_binaries
		side effects: remove etcd software (state 2)
		
	- install_service:
		condition: not installed
		purpose: install service files, load service, enable service.
		runs:
		- install_service
		side effects: configuration files are installed, directories created, service loaded and enabled (state 4)
		
	- uninstall_service:
		purpose: remove the service and all configuration files
		condition: not active, loaded
		depends: stop
		runs:
		- uninstall 
		side effects: clean configuration files and service file, delete directories (state 3)

	- start:
		purpose: start the service
		condition: loaded, binaries_installed
		depends: install, install_prerequisites
		runs:
		- start
		side effects: etcd service running (state 5)

	- stop:
		purpose: stop the service
		condition: active
		runs:
		- stop	
		side effects: etcd service stops (state 4)
			
	- status:
		- status
	

functions:
	install_etcd_bins: (state 2 -> 3)
		- check sudoer
		- download etcd binaries
		- install them
		returns: 0/1
	
	uninstall_etcd_bins (state 3 -> 2)
		- check sudoer
		- remove binaries
		returns: 0/1
	
	install_service: (state 2 -> 4)
		- check sudoer
		- check files exist
		- create directories
		- copy certificates
		- copy service files
		- enable service (if fails - remove previous steps)
		
	uninstall_service: (state 4 -> 2)
		- check status - if running
		- check status - if enabled
		- disable service
		- rm files and directories
	
	start: (state 4 -> 5)
		- check service is loaded (status)
		- check binaries installed (status)
		- start service
		
	stop: (state 5 -> 4)
		- check status - if running
		- check status - if loaded
		- stop service
	
	status:
		- returns a json
		{
			"active": true
			"loaded": true
			"etcd_installed": true
			"landed": true
		}
	
		



#############################
			
		
etcd_manager.sh
---------------

our strategy is as such:
for each command in etcd_agent, we'll have a corresponding 
command in etcd_manager, which will run on all nodes and execute
the command.
if one node fails, we'll print an error and continue, and return a failure status code

commands:
	 - create_deployment
	 	purpose: create a deployment directory with all files to copy to nodes
	 	runs:
	 	- create_deployment
	 	side effects: deployment directory
	 	
	 - delete_deployment - clean deployment directory
	 	purpose: delete deployment directory
	 	runs: clean
	 	side effects: deployment directory deleted
	 
	 - distribute
	 	purpose: distribute deployment to all nodes
		runs: distribute
		side effects: moves all nodes to "landed" state

     - clean_etcd_home:
		purpose: undo 'distribute'
		start state: 'landed', not installed, not loaded
		side effects: deletes etcd_home, moving nodes to 'clean' state
		if fails between nodes: raise error, continue to next node

        consider: checking that no node is in non-landed state (like active or installed)

	 - install_binaries
	 	purpose: install etcd binaries
	 	start state: 'landed', not installed, not loaded
	 	runs:
	 	- install_etcd_binaries
	 	side effects: etcd bins installed 

	 - uninstall_binaries
	 	purpose: undo 'install_binaries'
		start state: 'installed', not loaded
		runs:
		- uninstall_etcd_binaries
		if fails between nodes: raise error, continue to next node
        if not ready between nodes: raise error, continue to next node

	 - install_service
	 	purpose: install service on all nodes
		start state: binaries installed
		runs:
		- install_service
		side effects: loaded state

	 - uninstall_service
	 	purpose: undo install_service
	 	start state: 'loaded'
	 	runs:
	 	- uninstall_service
	 	side effects: service unintsalled on all nodes (state 'installed')
	 	if fails between nodes: error, continue to next nodes
        if not ready between nodes: same
	 
	 - start
	 	purpose: start etcd
	 	start state: 'loaded'
	 	runs:
	 	- start
	 	side effects: etcd up (state 5)
	 
	 - stop
	 	purpose: stop etcd
	 	start state: 'active'
	 	runs:
	 	- stop
	 	side effecst: etcd down (state 4)
	 	if fails between nodes: raise error, continue to next nodes
 
	 - test
	 	purpose: test etcd
	 	start state: 5
	 	runs:
	 	- test
	 
	 - status - returns a report of the etcd state
	 
	 - full_run - create_deployment, install binaries and service, start service
	 - reset
	 	purpose: leave no mark of etcd
	 	runs:
	 	- stop
	 	- 


functions:
	- clean_etcd_home - delete etcd_home directory from all nodes
	- create_deployment
		- patch agent script
		- generate service files
		
	- distribute
		- scp to all nodes
		remarks: if some node fails, delete from other nodes
	
	- clean_etcd_home
		- delete etcd_home from all nodes
		remarks: if some node fails, warn and continue
	
	- install_binaries
		does:
		- check status - should be 'landed'
		- run agent.sh install_binaries (state 3)
		remarks: if some node fails, clean previous nodes
	
	- uninstall_binaries
		does:
		- remove etcd binaries
		remarks: if some node fails, warn and continue
		
	- install_service
		depends: distribute
		does:
		- check status - should be uninstalled - if installed - raise warning and return
		- run agnet.sh install (state 4)
		remarks: if some node fails, uninstall from all nodes
		
	- uninstall_service
		does:
		- check status - should be installed
		- run agent.sh uninstall (state 3)
		remarks: if some node fails, warn and continue
		
	- start
		does:
		- check status - should be installed
		- start etcd service on all nodes
		remarks: if some node fails, stop previous nodes
		
	- stop
		does:
		- check status - should be started
		- stop etcd service on all nodes
		remarks: if some node fails, raise warning and continue
		
	- test
		test etcd is up and running
		
	- status
		does:
		- foreach node, display status




possible states:
1) clean - nothing on node
2) landed - files in k8s_home
3) etcd_installed - etcd binaries installed
4) loaded - files installed on machine, service enabled
5) started - service running

states 3 and 4 are not sequential but parallel - they don't depend on one another.
state 5 depends on both.



Mission: etcd_manager
Description:  refactor the etcd_manager script to match the new etcd_agent script
==========
Tasks
-----
1. refactor etcd_agent.sh
	we want to have a convention of status codes returned by the functions.
	failure -      1
	already-done - 2
	not-ready -    3
	so that when some node returns 3, etcd_manager detects this as an error
	and aborts the action.
2. create a generic function for processing on all nodes:
    the function receives:
        - function to perform
        - list of nodes
        - name of action
    the function iterate over the nodes, and run the function in question
    if fails, raise error and continue to next node




